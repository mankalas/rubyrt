#!/usr/bin/env ruby

require 'bundler/setup'

require 'ruby-prof'
require 'benchmark'
require 'optparse'
require 'byebug'

require 'image_exporter'
require 'objects'
require 'color'
require 'light'
require 'world'
require 'vec3d'

EPS = 1e-9

options = {}
OptionParser.new do |opts|
  opts.banner = 'Usage: console.rb [options]'

  opts.on('-h', '--height 1', Integer, 'Height of the rendered image') do |h|
    options[:height] = h
  end

  opts.on('-w', '--width 1', Integer, 'Widthof the rendered image') do |w|
    options[:width] = w
  end
end.parse!

w = World.new(options[:width], options[:height])
dif_pow = 20
spe_pow = 24

s1 = Sphere.new(Vec3d.new(-1, -1, 12), 4)
s1.color = Color::GREEN
s1.reflection = 1

s2 = Sphere.new(Vec3d.new(0.5, -0.5, 4), 1)
s2.refractive_index = 3.14
s2.transparency = 0.5
s2.reflection = 1
s2.color = Color::RED

s3 = Sphere.new(Vec3d.new(-2.5, 1, 6), 1.5)
s3.color = Color::BLUE
s3.reflection = 0.001
s3.transparency = 1

p1 = Plane.new(Vec3d.new(0, -5, 0), Vec3d.new(0, -1, 0))
p1.color = Color::WHITE

p2 = Plane.new(Vec3d.new(0, 8, 0), Vec3d.new(0, 1, 0))
p2.color = Color::WHITE

[
  # PointLight.new(Vec3d.new(-10, 10, -1), Color::GREEN, dif_pow, Color::GREEN, spe_pow),
  # PointLight.new(Vec3d.new(0, 10, -1), Color::RED, dif_pow, Color::RED, spe_pow),
  # PointLight.new(Vec3d.new(10, 10, -1), Color::BLUE, dif_pow, Color::BLUE, spe_pow),
  # PointLight.new(Vec3d.new(0, 0, -5), Color::WHITE, dif_pow, Color::WHITE, spe_pow),
  # Sphere.new(Vec3d.new(0, 0, 10), 4, Color::GREEN),
  # Sphere.new(Vec3d.new(-2, 1, 4), 1, Color::BLUE),
  # Sphere.new(Vec3d.new(2, -1, 4), 1.5, Color::RED),

  # Plane.new(Vec3d.new(0, 0, -15), Vec3d.new(0, 0, -1), Color.new(1, 1, 0)),

  s1, s2,# s3,
  p1, p2,
  PointLight.new(Vec3d.new(0.75, -6, 8), Color::WHITE, 35, Color::WHITE, 35),

].each { |obj| w.add(obj) }

puts "Rendering world"
# profile the code
#result = RubyProf.profile do
puts Benchmark.measure { w.render }
#end
# print a graph profile to text
#printer = RubyProf::FlatPrinter.new(result)
#printer.print(STDOUT, {})

puts "Saving image"
puts Benchmark.measure { w.image.write_png('test') }
